# -*- coding: utf-8 -*-
"""
@author: Radoslav Å koviera

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""

from knowl import OntologyDatabase, DBConfig
from rdflib import URIRef, BNode, Literal
from rdflib.term import Identifier
from rdflib.namespace import Namespace, RDF, RDFS, OWL, FOAF
from collections import defaultdict
from collections.abc import Iterable
from itertools import chain
from rdflib.extras.infixowl import classOrIdentifier
import re


class OntologyAPI(OntologyDatabase):

    __databaseDict = {}

    def __new__(cls, config=None, *args, **kwargs):
        """Returns an ontology database. The ontologies are identified by the uniqueID
        generated by the DBConfig object. This ID depends on the specific database server,
        database and the ontology (identified by ontology IRI). In order for this to work,
        the access credentials also has to be specified.

        Parameters
        ----------
        config : DBConfig or str
            [description]

        Returns
        -------
        OntologyDatabase
        """
        config = DBConfig.factory(config)  # factory enables config specification in several formats, this line unifies them.
        id = config.uniqueID  # get the unique ID for the specific database+ontology
        if id in cls.__databaseDict:  # if ontology was already initialized in this program session, retrieve its reference
            db = cls.__databaseDict[id]
        else:  # otherwise create new ontology connection
            # db = OntologyAPI(config=config)
            db = super().__new__(cls)
            cls.__databaseDict[id] = db
        return db

    def __init__(self, config=None):
        super().__init__(config=config, create=True)
        self.setup()
        self.__objects = {}
        self.__nss = {ns[0]: Namespace(ns[1]) for ns in self._graph.namespaces()}

        self.__baseNamespace = self.namespaces["base"]

    @property
    def namespaces(self):
        """Returns a dictionary of namespaces binded to the database
        """
        return self.__nss

    @property
    def baseNS(self):
        return self.__baseNamespace

    def getProperty(self, property):
        # TODO
        pass

    def existEntity(self, reference, anyRecord: bool = False):
        """Checks if the entity corresponding to the reference exists in the ontology.

        Parameters
        ----------
        reference : RDF.term
            reference to the entity
        anyRecord : bool, optional
            If set to True, will search for any entry referencing the object. If set to False,
            existence of the entity's type is required (searched for). By default False

        Returns
        -------
        bool
            Whether the specified entity exists within the database
        """
        if anyRecord:
            predicate = None
        else:
            predicate = RDF.type
        return (reference, predicate, None) in self._graph

    def getEntity(self, reference, makeIfDoesNotExist: bool = False):
        """Returns a proxy to an entity in the ontology.
        If the object corresponding to the reference already exists in the database then simply the reference
        is returned. If it does not exist, it will be created.

        Parameters
        ----------
        reference : Identifier
            [description]

        makeIfDoesNotExist : bool
            If set to True, a blank entity with the specified reference will be created and returned.
            I.e., an entity will be created even if one does not exist within the database.

        Returns
        -------
        OntoEntity
            A proxy for the entity in the ontology.
        """
        # create empty object as a default return value if no object exist and create is False
        obj = None
        # make sure reference is a valid identifier
        if isinstance(reference, str):
            reference = URIRef(reference)
        # create reference string
        refString = reference.n3()
        # check if the referenced objects is remembered by the API
        if refString in self.__objects:
            obj = self.__objects[refString]
            # check if the referenced object still exists within the DB
            if not obj.exists:
                # if the object is no longer in DB, remove it from the dict and return None
                del self.__objects[refString]
                return None
        else:
            # check if the reference exist within the database
            if self.existEntity(reference):
                # TODO: obj =  # make new object but don't write into DB (it's already there)
                pass
            elif makeIfDoesNotExist:
                obj = self.makeEntity(reference)
        return obj

    def makeEntity(self, reference, attributes: dict = {}, **kwargs):
        """Creates and object in this ontology
        Objects should only be created using this function (i.e. not by instantiating the OntoObject class directly).
        The main reason for this is that the OntoObject does not existence of such object in the current ontology
        and thus duplicates could be produced.

        Parameters
        ----------
        reference : URIRef or similar
            URI reference of the object to be created. If the provided reference referres to a class a new object
            is instantiated instead of providing reference to an object already existing in the database.

        Returns
        -------
        OntoEntity
            A proxy for the entity in the ontology.
        """
        refString = reference.n3()
        # merge the attributes
        attributes = {**attributes, **self.__expandPythonAttributes(kwargs)}
        # check if the referenced objects is remembered by the API
        obj = self.getEntity(reference, makeIfDoesNotExist=False)
        if obj is not None:
            # update the objects attributes according to the provided parameters
            obj[attributes.keys()] = attributes.values()
        else:
            # if not, check if it is a class
            if (reference, RDF.type, OWL.Class) in self:
                # if the reference is class, create a new object using that class
                obj = OntoEntity(self, **{**{RDF.type: reference}, **attributes})
            else:
                # This kind of entity creation assumes that the class/type of the entity is specified in the attributes!!!
                obj = OntoEntity(self, name=reference, **attributes)
            self.__objects[refString] = obj
        return obj

    def __getattr__(self, key):
        """Properties that do not exist as a part of this class are returned as URI from the base namespace
        """
        if key.startswith("_") or key in self.__dir__():
            return super().__getattribute__(key)
        else:
            # return self.baseNS[key]
            return ProxyReference(key, self.baseNS, self.makeEntity)

    def __expandPythonAttributes(self, pyattributes):
        # TODO: Translate python named attributes into URIRefs
        """Calling a function with optional "kwargs" is only possible
        if the kwargs keys are simple expressions (e.g., type)
        and not complex expressions like for example calls to object
        methods or expressions containing control characters (e.g., #).
        Thus something like "makeEntity(ref, RDF.type=OWL.Class) is not possible.
        The RDF.type results in invalid syntax. A workaround is  to call the function
        with a dictionary containing this definition but that is not elegant.
        The goals of this function is to allow call like makeEntity(ref, type=OWL.Class, subClassOf=BASE.SomeClass)
        and translate the keys from ["type", "subClassOf"] into [RDF.type, OWL.subClassOf],
        thus allowing this simplified function call.

        Parameters
        ----------
        pyattributes : dict
            The input dictionary with keys in simple form that needs to be expanded.

        Returns
        -------
        dict
            A dictionary containing much the same values but the keys are expanded into URIRefs.
        """
        self._graph.compute_qname
        return pyattributes

    def getEntsByClass(self, cls, typePredicate: URIRef = RDF.type):
        """Returns a list of entities of the specified class or type.

        Parameters
        ----------
        cls : [str, URIRef]
            The identifier of the class to be searched for.

        typePredicate : URIRef, optional
            This paramaters can optionally by changed to modify the predicate
            denoting the "entity is of class" statement. Under normal circumstances,
            there shall be no need to actually change this, by default RDF.type.

        Returns
        -------
        list of OntoEntity
            A list of objects with the specified type.
        """
        pass

    def isAncestorOf(self, alleged_ancestor, thing):
        # FIXME: there simply HAS TO BE a better way
        return classOrIdentifier(alleged_ancestor) in self.transitive_objects(classOrIdentifier(thing), RDFS.subClassOf)


# TODO: maybe more thought should be put into this
uriMatchingRegex = re.compile(r".+\/\w+\.\w+", re.IGNORECASE)


def isValidURI(ref):
    return uriMatchingRegex.search(ref) is not None


def castIntoProperURI(ref, baseNS):
    if not isValidURI(ref):
        ref = baseNS[ref]
    return ref


def castIntoValidTerm(val):
    if val is None:
        return BNode()
    elif not isinstance(val, (Identifier, Literal)):
        if isinstance(val, str) and isValidURI(val):
            val = URIRef(val)
        else:
            val = Literal(val)
    return val


class ProxyReference(URIRef):

    def __new__(cls, name, namespace, caller, *args, **kwargs):
        value = namespace[name]
        base = None
        return super().__new__(cls, value, base)

    def __init__(self, name, namespace, caller):
        super().__init__()
        self._ns = namespace
        self._caller = caller

    def __call__(self, **kwargs):
        return self._caller(self, {self._ns[k]: castIntoValidTerm(v) for k, v in kwargs.items()})


class ProxyAttribute():
    """This object serves as proxy for OntoEntity's property.
    It is a "hack" to make namespace work in the dot notation.
    I.e., entity.Namespace.property
    """

    def __init__(self, ns, caller):
        self._ns = ns
        self._caller = caller

    def __setattr__(self, key, value):
        if key.startswith("_"):
            super().__setattr__(key, value)
        else:
            self._caller[self._ns[key]] = value

    def __getattr__(self, key):
        if key.startswith("_"):
            super().__getattribute__(key)
        else:
            return self._caller[self._ns[key]]


class OntoProperty():
    """Proxy for ontologic property/predicate.
    Contains various properties for quick access - i.e. properties like "functional"
    can be queried from this proxy instead of the database, which should provide
    some speedup. Only works if properties are queried multiple times (the first time
    everything has to be loaded from the database).
    Also, provides convenience access using the OOP approach.

    TODO
    """

    def __init__(self, onto: OntologyAPI, **kwargs):
        self.__onto = onto


class OntoEntity():
    """Ontology entity (subject or object)
    This class provides a convenience access to the entities inside the ontologic database.
    Creating this object directly is not recommended. Use OntologyAPI.makeObject or similar function instead.

    # TODO: check whether an object should be a VALUE or not (i.e. update only once)
    """

    def __init__(self, onto: OntologyAPI, **kwargs):
        # kwargs = defaultdict(lambda: None, kwargs)

        self.__onto = onto
        self.__baseNS = self.__onto.baseNS

        if "name" in kwargs:
            self.__node = BNode(kwargs["name"])
            del kwargs["name"]
        else:
            self.__node = BNode()

        if len(kwargs) > 0:
            self[kwargs.keys()] = kwargs.values()

    def __repr__(self):
        return self.node

    def __str__(self):
        return self.node.toPython()

    def n3(self, namespace_manager=None):
        return self.node.n3(namespace_manager=namespace_manager)

    def __getattr__(self, key):
        """Working examples:

        entity.Namespace.property
        entity.property; where property is a valid predicate in the ontology
        """
        if key.startswith("_") or key in self.__dir__():
            return super().__getattribute__(key)
        elif key.lower() in self.__onto.namespaces:
            return ProxyAttribute(self.__onto.namespaces[key.lower()], self)
        else:
            q = (self.node, castIntoProperURI(key, self.__baseNS), None)
            ans = [a[2] for a in self.__onto.triples(q)]
            if len(ans) == 1:
                return ans[0]
            else:
                return ans

    def __setattr__(self, key, value):
        """Working examples

        entity.Namespace.property = value
        entity.property = value; where property is a valid predicate in the ontology

        """
        if key.startswith("_") or key in self.__dir__():
            super().__setattr__(key, value)
        else:
            if key.lower() in self.__onto.namespaces:
                return ProxyAttribute(self.__onto.namespaces[key.lower()], self)
            else:
                value = castIntoValidTerm(value)
                # TODO: take care of "set" values!
                q = (self.node, castIntoProperURI(key, self.__baseNS), value)
                self.__onto.set(q)

    def __setitem__(self, keys, values):
        """Working examples

        entity[Namespace.property] = value
        entity[property] = value; where property is a valid predicate in the ontology
        entity[Namespace.property1; OtherNamespace.property2] = [value1, value2]; works for any number of property/value pairs
        entity[property1, property2] = [value1, value2]; where property is a valid predicate in the ontology; works for any number of property/value pairs

        Values can be provided as Identifiers or as Python variables (these will be converted into Literals).
        """
        # check if multiple values were provided
        if isinstance(keys, Iterable) and not (isinstance(keys, Identifier) or isinstance(keys, str)):
            # form multiple triples and send them at once to the database
            for k in keys:
                # Remove previous entries with the same property, i.e. perform an "update" - maybe change this in the future
                self.__onto.remove((self.node, k, None))
            self.__onto.addN([(self.node, castIntoProperURI(k, self.__baseNS), castIntoValidTerm(v)) for (k, v) in zip(keys, values)])
        else:
            # is only a single field is to be updated, use the setattr method
            self.__setattr__(keys, values)

    def __getitem__(self, keys):
        """Working examples

        entity[Namespace.property]
        entity[property]; where property is a valid predicate in the ontology
        entity[Namespace.property1; OtherNamespace.property2]; works for any number of properties
        entity[property1, property2]; where property is a valid predicate in the ontology; works for any number of properties

        The later two examples will return a list of values.
        """
        if isinstance(keys, Iterable) and not (isinstance(keys, Identifier) or isinstance(keys, str)):
            # form multiple triples and send them at once to the database
            ans = list(chain(*[self.__onto.objects(self.node, castIntoProperURI(k, self.__baseNS)) for k in keys]))
            return ans
        else:
            # is only a single field is to be updated, use the setattr method
            return self.__getattr__(keys)

    @property
    def list(self):
        return list(self.__onto.triples((self.node, None, None)))

    @property
    def properties(self):
        return list(self.__onto.predicate_objects(self.node))

    @property
    def usage(self):
        return list(self.__onto.subject_predicates(self.node))

    @property
    def type(self):
        ans = list(self.__onto.objects(subject=self.node, predicate=RDF.type))
        return ans[0] if len(ans) == 1 else ans

    @property
    def localType(self):
        """Returns local type of this entity.
        That is, only the last part of the type URI (e.g., "Cube")
        """
        globalType = self.type
        if isinstance(globalType, list):
            localType = [self.__onto.compute_qname(t)[2] for t in globalType]
        else:
            _, _, localType = self.__onto.compute_qname(globalType)
        return localType

    # def _set_type(self, kind):
    # TODO:
    #     if not kind:
    #         return
    #     if isinstance(kind, (Individual, Identifier)):
    #         self.graph.add(
    #             (self.identifier, RDF.type, classOrIdentifier(kind)))
    #     else:
    #         for c in kind:
    #             assert isinstance(c, (Individual, Identifier))
    #             self.graph.add(
    #                 (self.identifier, RDF.type, classOrIdentifier(c)))

    def __delattr__(self, name):
        """Deletes the specified property of this entity from the database
        """
        if name.startswith("_") or name in self.__dir__():
            return super().__delattr__(name)
        else:
            return self.__onto.remove((self.node, name, None))

    def destroy(self):
        """Removes any entries containing this entity. Removes entries containing this entity
        as subjects and objects alike.
        """
        # TODO: more careful removal
        self.__onto.remove((self.node, None, None))
        self.__onto.remove((None, None, self.node))

    @property
    def exists(self):
        """Returns whether this entity is still contained in the database.
        More specifically, whether there are any entries containing this entity
        as subject.

        Returns
        -------
        bool
            Whether the entity is in the ontology
        """
        return (self.node, None, None) in self.__onto

    @property
    def node(self):
        """BNode or other Identifier identifying this entity in the database

        Returns
        -------
        Identifier
        """
        return self.__node
